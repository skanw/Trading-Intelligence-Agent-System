"""
Base Agent Class for Trading Intelligence Agent System
"""

import asyncio
import logging
import json
import time
from abc import ABC, abstractmethod
from datetime import datetime, timezone
from typing import Dict, List, Any, Optional, Union
from dataclasses import dataclass, asdict
import redis
# import aioredis  # Temporarily disabled due to Python 3.11+ compatibility issues
from kafka import KafkaProducer, KafkaConsumer
from kafka.errors import KafkaError

from ..config import config, AGENT_REGISTRY


@dataclass
class AgentMessage:
    """Standard message format for inter-agent communication"""
    agent_id: str
    timestamp: datetime
    message_type: str
    data: Dict[str, Any]
    priority: int = 5  # 1=highest, 10=lowest
    correlation_id: Optional[str] = None
    
    def to_json(self) -> str:
        data = asdict(self)
        data['timestamp'] = self.timestamp.isoformat()
        return json.dumps(data, default=str)
    
    @classmethod
    def from_json(cls, json_str: str) -> 'AgentMessage':
        data = json.loads(json_str)
        data['timestamp'] = datetime.fromisoformat(data['timestamp'])
        return cls(**data)


@dataclass
class AgentSignal:
    """Trading signal generated by agents"""
    symbol: str
    signal_type: str  # 'BUY', 'SELL', 'HOLD', 'ALERT'
    strength: float  # 0.0 to 1.0
    confidence: float  # 0.0 to 1.0
    price_target: Optional[float] = None
    stop_loss: Optional[float] = None
    time_horizon: Optional[str] = None  # 'SHORT', 'MEDIUM', 'LONG'
    reasoning: Optional[str] = None
    data_sources: List[str] = None
    
    def __post_init__(self):
        if self.data_sources is None:
            self.data_sources = []


class BaseAgent(ABC):
    """
    Base class for all trading agents providing common functionality
    """
    
    def __init__(self, agent_id: str, config_override: Optional[Dict] = None):
        self.agent_id = agent_id
        self.config = config_override or {}
        self.logger = self._setup_logger()
        self.is_running = False
        self.last_heartbeat = datetime.now(timezone.utc)
        
        # Redis connections for caching and pub/sub
        self.redis_client = None
        self.redis_async = None
        
        # Kafka for message streaming
        self.kafka_producer = None
        self.kafka_consumer = None
        
        # Agent registry information
        self.agent_info = AGENT_REGISTRY.get(agent_id, {})
        self.frequency = self.agent_info.get('frequency', 60)
        self.dependencies = self.agent_info.get('dependencies', [])
        
        # Performance metrics
        self.metrics = {
            'messages_sent': 0,
            'messages_received': 0,
            'signals_generated': 0,
            'errors': 0,
            'avg_processing_time': 0.0,
            'uptime_start': datetime.now(timezone.utc)
        }
        
    def _setup_logger(self) -> logging.Logger:
        """Setup agent-specific logger"""
        logger = logging.getLogger(f"agents.{self.agent_id}")
        handler = logging.FileHandler(f'logs/agents/{self.agent_id}.log')
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
        return logger
    
    async def initialize(self):
        """Initialize agent connections and resources"""
        try:
            # Initialize Redis connections
            self.redis_client = redis.Redis(
                host=config.infrastructure.redis_host,
                port=config.infrastructure.redis_port,
                db=config.infrastructure.redis_db,
                decode_responses=True
            )
            
            # Async Redis temporarily disabled due to compatibility issues
            # self.redis_async = await aioredis.from_url(
            #     f"redis://{config.infrastructure.redis_host}:{config.infrastructure.redis_port}"
            # )
            self.redis_async = None
            
            # Initialize Kafka connections
            self._setup_kafka()
            
            # Call agent-specific initialization
            await self.agent_initialize()
            
            self.logger.info(f"Agent {self.agent_id} initialized successfully")
            
        except Exception as e:
            self.logger.error(f"Failed to initialize agent {self.agent_id}: {e}")
            raise
    
    def _setup_kafka(self):
        """Setup Kafka producer and consumer"""
        try:
            self.kafka_producer = KafkaProducer(
                bootstrap_servers=config.infrastructure.kafka_brokers,
                value_serializer=lambda v: json.dumps(v, default=str).encode('utf-8'),
                key_serializer=lambda k: k.encode('utf-8') if k else None
            )
            
            # Each agent subscribes to its own topic and common topics
            topics = [f"agent-{self.agent_id}", "system-broadcast", "market-alerts"]
            
            self.kafka_consumer = KafkaConsumer(
                *topics,
                bootstrap_servers=config.infrastructure.kafka_brokers,
                value_deserializer=lambda m: json.loads(m.decode('utf-8')),
                group_id=f"agent-group-{self.agent_id}",
                auto_offset_reset='latest'
            )
            
        except Exception as e:
            self.logger.error(f"Failed to setup Kafka for {self.agent_id}: {e}")
            raise
    
    async def start(self):
        """Start the agent's main execution loop"""
        if self.is_running:
            self.logger.warning(f"Agent {self.agent_id} is already running")
            return
            
        self.is_running = True
        self.logger.info(f"Starting agent {self.agent_id}")
        
        # Start background tasks
        tasks = [
            asyncio.create_task(self._main_loop()),
            asyncio.create_task(self._message_processor()),
            asyncio.create_task(self._heartbeat_loop())
        ]
        
        try:
            await asyncio.gather(*tasks)
        except Exception as e:
            self.logger.error(f"Error in agent {self.agent_id}: {e}")
            await self.stop()
    
    async def stop(self):
        """Stop the agent gracefully"""
        self.logger.info(f"Stopping agent {self.agent_id}")
        self.is_running = False
        
        # Close connections
        if self.kafka_producer:
            self.kafka_producer.close()
        if self.kafka_consumer:
            self.kafka_consumer.close()
        if self.redis_async:
            await self.redis_async.close()
        if self.redis_client:
            self.redis_client.close()
        
        # Call agent-specific cleanup
        await self.agent_cleanup()
    
    async def _main_loop(self):
        """Main execution loop running at specified frequency"""
        while self.is_running:
            try:
                start_time = time.time()
                
                # Execute agent-specific logic
                await self.execute()
                
                # Update performance metrics
                processing_time = time.time() - start_time
                self._update_metrics(processing_time)
                
                # Sleep until next execution
                await asyncio.sleep(self.frequency)
                
            except Exception as e:
                self.logger.error(f"Error in main loop for {self.agent_id}: {e}")
                self.metrics['errors'] += 1
                await asyncio.sleep(self.frequency)
    
    async def _message_processor(self):
        """Process incoming messages from other agents"""
        while self.is_running:
            try:
                # Process Kafka messages
                for message in self.kafka_consumer:
                    if not self.is_running:
                        break
                        
                    agent_message = AgentMessage.from_json(json.dumps(message.value))
                    await self.handle_message(agent_message)
                    self.metrics['messages_received'] += 1
                    
            except Exception as e:
                self.logger.error(f"Error processing messages for {self.agent_id}: {e}")
                await asyncio.sleep(1)
    
    async def _heartbeat_loop(self):
        """Send periodic heartbeat to orchestrator"""
        while self.is_running:
            try:
                self.last_heartbeat = datetime.now(timezone.utc)
                
                heartbeat_data = {
                    'agent_id': self.agent_id,
                    'timestamp': self.last_heartbeat.isoformat(),
                    'status': 'healthy',
                    'metrics': self.metrics
                }
                
                await self.send_message(
                    'orchestrator-agent',
                    'heartbeat',
                    heartbeat_data,
                    priority=10
                )
                
                await asyncio.sleep(30)  # Heartbeat every 30 seconds
                
            except Exception as e:
                self.logger.error(f"Error sending heartbeat for {self.agent_id}: {e}")
                await asyncio.sleep(30)
    
    async def send_message(self, target_agent: str, message_type: str, 
                          data: Dict[str, Any], priority: int = 5,
                          correlation_id: Optional[str] = None):
        """Send message to another agent"""
        try:
            message = AgentMessage(
                agent_id=self.agent_id,
                timestamp=datetime.now(timezone.utc),
                message_type=message_type,
                data=data,
                priority=priority,
                correlation_id=correlation_id
            )
            
            # Send via Kafka
            topic = f"agent-{target_agent}"
            self.kafka_producer.send(topic, value=message.to_json())
            
            self.metrics['messages_sent'] += 1
            self.logger.debug(f"Sent {message_type} message to {target_agent}")
            
        except Exception as e:
            self.logger.error(f"Failed to send message to {target_agent}: {e}")
            raise
    
    async def broadcast_signal(self, signal: AgentSignal):
        """Broadcast trading signal to all interested agents"""
        try:
            signal_data = asdict(signal)
            signal_data['agent_id'] = self.agent_id
            signal_data['timestamp'] = datetime.now(timezone.utc).isoformat()
            
            # Send to signals topic
            topic = config.infrastructure.kafka_topics['signals']
            self.kafka_producer.send(topic, value=signal_data)
            
            self.metrics['signals_generated'] += 1
            self.logger.info(f"Broadcasted {signal.signal_type} signal for {signal.symbol}")
            
        except Exception as e:
            self.logger.error(f"Failed to broadcast signal: {e}")
            raise
    
    def cache_data(self, key: str, data: Any, expiry: int = 3600):
        """Cache data in Redis with expiry"""
        try:
            cache_key = f"{self.agent_id}:{key}"
            self.redis_client.setex(
                cache_key, 
                expiry, 
                json.dumps(data, default=str)
            )
        except Exception as e:
            self.logger.error(f"Failed to cache data: {e}")
    
    def get_cached_data(self, key: str) -> Optional[Any]:
        """Retrieve cached data from Redis"""
        try:
            cache_key = f"{self.agent_id}:{key}"
            data = self.redis_client.get(cache_key)
            return json.loads(data) if data else None
        except Exception as e:
            self.logger.error(f"Failed to retrieve cached data: {e}")
            return None
    
    def _update_metrics(self, processing_time: float):
        """Update agent performance metrics"""
        self.metrics['avg_processing_time'] = (
            self.metrics['avg_processing_time'] * 0.9 + processing_time * 0.1
        )
    
    # Abstract methods that must be implemented by subclasses
    @abstractmethod
    async def agent_initialize(self):
        """Agent-specific initialization logic"""
        pass
    
    @abstractmethod
    async def execute(self):
        """Main execution logic for the agent"""
        pass
    
    @abstractmethod
    async def handle_message(self, message: AgentMessage):
        """Handle incoming messages from other agents"""
        pass
    
    @abstractmethod
    async def agent_cleanup(self):
        """Agent-specific cleanup logic"""
        pass 